尝试lock
ldb_spinlock(&lock);

if (!ldb_path_absolute(path, sizeof(path) - 35, dbname))

(gdb) p path
$3 = "/data1/guangkun/lcdb/tmp", '\000' <repeats 752 times>...

 db = ldb_create(path, options);

ldb_t *db = ldb_malloc(sizeof(ldb_t));

memcpy(db->dbname, dbname, len + 1);

db->owns_cache = (db->options.block_cache != options->block_cache);

7835	  db->table_cache = ldb_tables_create(db->dbname,
7836	                                      &db->options,
7837	                                      table_cache_size(&db->options));

table_cache_size (sanitized_options=0x6320e0) at lcdb.c:7687
7687	  return sanitized_options->max_open_files - non_table_cache_files;

(gdb) p non_table_cache_files
$7 = 10
(gdb) p sanitized_options->max_open_files 
$8 = 1000

创建cache
ldb_tables_t *cache = ldb_malloc(sizeof(ldb_tables_t));

cache->lru = ldb_lru_create(entries);

(gdb) p entries
$10 = 990

ldb_rename_file(info, old);
ldb_rename_file (from=0x7fffffffd3d0 "/data1/guangkun/lcdb/tmp/LOG", to=0x7fffffffd7d0 "/data1/guangkun/lcdb/tmp/LOG.old") at lcdb.c:11833

7635	  if (result.block_cache == NULL)
(gdb) 
7636	    result.block_cache = ldb_lru_create(8 << 20);


lru_shard_init (lru=0x632970) at lcdb.c:7559

lru_table_init(&lru->table);

lru_table_resize(tbl);

7868	  db->versions = ldb_versions_create(db->dbname,
7869	                                     &db->options,
7870	                                     db->table_cache,
7871	                                     &db->internal_comparator);

ldb_versions_create
ldb_versions_t *vset = ldb_malloc(sizeof(ldb_versions_t));

ldb_versions_init(vset, dbname, options, table_cache, cmp);

ldb_versions_init

vset->next_file_number = 2;

vset->manifest_file_number = 0; /* Filled by recover(). */

vset->current = NULL;

ldb_version_init(&vset->dummy_versions, vset);
vset 通过 dummy_versions_ 来维护所有 Version 对象的生命周期

ldb_version_init (ver=0x634830, vset=0x6347b0) at lcdb.c:7722

ver->vset = vset;

ldb_buffer_init(&vset->compact_pointer[level]);
在 LevelDB 的 size-compaction 里，一次最多只会选 一层里相邻的、总大小不超过配置阈值 的 SST 文件，具体规则如下：
从 compact_pointer_[level] 往后扫，按 文件顺序 把相邻文件累加。
当 vset->compact_pointer_[level] 指向的 key 已经 超过该层最大 key（即“找不到文件”）时，LevelDB 会 把指针回卷到该层第一个文件，继续按顺序挑文件做 size-compaction。

ldb_versions_append_version(vset, ldb_version_create(vset));
ldb_version_create(vset)
以当前 VersionSet 里 正在使用的 Version（vset->current_） 为模板，新建一个空的 Version 对象，
ldb_versions_append_version(vset, ...)
把刚建好的新版本插到 vset->dummy_versions_ 双向循环链表的尾部（紧贴在 dummy_versions_ 之前），并：
让 vset->current_ 指向它，使之成为 最新当前版本；
把旧版本的引用计数减 1；若引用为 0，就把旧版本从链表摘掉并释放内存。

ldb_version_init 创建代码里面只有初始化文件

v->prev = vset->dummy_versions.prev;   // 1. 新节点的前驱指向“旧尾节点”
v->next = &vset->dummy_versions;       // 2. 新节点的后继指向“哨兵头节点”
vset->dummy_versions 是头节点；



(gdb) p vset->dummy_versions
$29 = {vset = 0x6347b0, next = 0x6349d0, prev = 0x6349d0, refs = 0, files = {{items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, 
      alloc = 0}, {items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, alloc = 0}}, file_to_compact = 0x0, file_to_compact_level = -1, compaction_score = -1, 
  compaction_level = -1}
(gdb) p vset->dummy_versions.next
$30 = (ldb_version_t *) 0x6349d0
(gdb) p *vset->dummy_versions.next
$31 = {vset = 0x6347b0, next = 0x634830, prev = 0x634830, refs = 1, files = {{items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, 
      alloc = 0}, {items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, alloc = 0}, {items = 0x0, length = 0, alloc = 0}}, file_to_compact = 0x0, file_to_compact_level = -1, compaction_score = -1, 
  compaction_level = -1}
(gdb) p &vset->dummy_versions
$32 = (ldb_version_t *) 0x634830
(gdb) p vset->dummy_versions.next
$33 = (ldb_version_t *) 0x6349d0


ldb_version_init(&vset->dummy_versions, vset)
只是把 dummy_versions 这个栈上/静态分配的哨兵初始化成“空 Version”状态，让它的 prev/next 指向自己，形成空双向循环链表。
此时 vset->current_ == NULL，数据库仍然没有一个可查询的正式 Version。
ldb_versions_append_version(vset, ldb_version_create(vset))
ldb_version_create 会在堆里克隆当前的 Manifest 文件里记录的那一套 SST 文件元信息，生成第一个真正的、带数据的 Version。
append_version 把它插到链表尾部，并令 vset->current_ = 这个新 Version。



ldb_edit_init(&edit);

出现在 LevelDB 提交一次版本变更之前（LogAndApply 里），作用是把 VersionEdit 结构体归零，让它准备好记录“这次要改什么”

ldb_edit_init

前面都是初始化各种结构体

rc = ldb_recover(db, &edit, &save_manifest);

ldb_recover

if (!ldb_lock_filename(path, sizeof(path), db->dbname))

rc = ldb_lock_file(path, &db->db_lock);

p path
$7 = "/data1/guangkun/lcdb/tmp/LOCK

if (!ldb_current_filename(path, sizeof(path), db->dbname))

(gdb) p path
$4 = "/data1/guangkun/lcdb/tmp/CURRENT

rc = ldb_new_db(db);

if (!ldb_desc_filename(manifest, sizeof(manifest), db->dbname, 1))

sprintf(tmp, "MANIFEST-%s", id);

rc = ldb_truncfile_create(manifest, &file);

p manifest
$18 = "/data1/guangkun/lcdb/tmp/MANIFEST-000001

ldb_edit_init(&new_db);

ldb_edit_set_next_file(&new_db, 2);

ldb_writer_init(&log, file, 0);

ldb_edit_export(&record, &new_db);

rc = ldb_versions_recover(db->versions, save_manifest);

ldb_versions_recover

rc = read_current_filename(fname, sizeof(fname), vset->dbname);

read_current_filename

rc = ldb_read_file(path, &data);

name = (char *)data.data;

(gdb) p name
$5 = 0x634b70 "MANIFEST-000048\n"

9073	    ldb_reader_init(&reader, file, &reporter, 1, 0);
(gdb) p file
$11 = (struct ldb_rfile_s *) 0x634b20
(gdb) p *file
$12 = {filename = 0x0, fd = 9, limiter = 0x0, mapped = 0, base = 0x0, length = 0, mutex = {handle = 0x0}, has_mutex = 0}







